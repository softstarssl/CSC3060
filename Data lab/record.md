# record

## bitXor
这个比较简单了，没什么好说的
~~~cpp
int bitXor(int x, int y) 
{
  return (~(x & y) & ~(~x & ~y));
}
~~~

## tmin
补码的数值计算式：$-2^{31}·b_{31} + \sum_{i = 0}^{30} 2^i · b_i$

所以当补码的最高位是1,后面的全都是0，可以得到补码表示法能表示的最小值 $-2^{31}$
其补码就是 (1 << 31)
~~~cpp
int tmin(void) 
{
  //Tmin = 1000...0000
  return 1 << 31;

}
~~~

## isTmax
判断传入的数是不是最大数: 01111....111

具体的写到代码里面了
~~~cpp
int isTmax(int x) 
{
  //Tmax 的性质-> ~x = x + 1
  //注意到 -1 同样也有这个性质
  //所以判断 !(x + 1) 来排除 -1 的情况
  int y = x + 1;
  return !((~x ^ y) | (!y));
}
~~~

## allOddBits
判断当前数字其奇数上面是否为全部为1，特别注意最低位是第0位

注意到 $A_{(16)} = 10_{(10)} = 1010_{(2)},AA = 1010101_{(2)}$,一个十六进制字符占据着四个二进制字节,以此我们扩展到32位，就是 $AAAAAAAA_{(16)}$ 就是我们要找的一个标准数字$\text{mask}$，然后我们用传入这个数与mask做 & 运算，看看是否与mask 相等
~~~cpp
int allOddBits(int x) 
{
  int mask = 0xAA | (0xAA << 8);
  mask = mask | (mask << 16);
  return !(mask ^ (mask & x));
}
~~~
## negate
最经典的求解负数，经典公式
~~~cpp
int negate(int x) 
{
  return ~x + 1;
}
~~~

## isAsciiDigit
判断这个字符是不是满足 $0x30\leq x \leq 0x39$

其实就是判断 x - 0x30和0x39 - x 是不是负数罢了，x - 0x30 = x + (-0x30) = x + (~0x30 + 1)
~~~cpp
int isAsciiDigit(int x) 
{
  int tmin = 1 << 31;
  int inf = x + (~0x30 + 1); //x - 0x30
  int sup = 0x39 + (~x + 1); //0x39 - x
  //检查符号位是否为0
  return !((inf & tmin) | (sup & tmin));
}
~~~

## conditional
返回条件语句 x?y:z;

首先将 x 变为最好分析的 0000000... 和 1....，使用 x = !x，则 x = 0 时将 x 转化为 1 ，反之将 x 转化为0，然后 x = -x (~x + 1)，就能将 0 转化成0000000...，1转化成111111...，（特别注意这里的0/1和最开始是相反的！！！所以后面似 y & ~x 而不是 y & x）然后 y & ~x | z & x来判断该返回哪个
~~~cpp
int conditional(int x, int y, int z) 
{
  x = !x; //x为0时变为1，x非0时变为0
  x = ~x + 1; //x为0时变为0x00000000，x非0时变为0xFFFFFFFF
  return (y & ~x) | (z & x);
}
~~~

## isLessOrEqual
实现一个$\leq$ 符号

令 $diff = y - x = y + (~x + 1)$，我们只需要判断 x,y,diff 三者的符号
首先如果 tagx是1,tagy是0，那么x为负y为正，直接返回1 

如果二者符号相同，并且diff的符号位是0，则diff非负，意味着$ 0\leq diff = y - x$，也返回1
~~~cpp
int isLessOrEqual(int x, int y) 
{
  int diff = y + (~x + 1); //y - x
  int tagx = (x >> 31) & 1; //x的符号位
  int tagy = (y >> 31) & 1; //y的符号位
  int tagdiff = (diff >> 31) & 1; //y - x 的符号位
  //x和y符号位相同，则看y - x 的符号位
  //x和y符号位不同，则看x的符号位
  return (tagx & !tagy) | (!(tagx ^ tagy) & !tagdiff);
}
~~~

## logicalNeg
这里是不用 ! 实现 ! 的操作，其实就是判断一个数是不是0

0的重要性质： 0 = -0 ，也就是说我们直接对 x 和 -x 判断其符号位是否相同就好了

这里涉及到了算术右移这个东西，突然发现自己对于 >> 这个符号的理解这么多年没有搞明白，记录一下：

对于有符号整数，C++执行的是算数右移：对于有符号整数 x ，每执行一次 >> 1，相当于在 x 左边加入 x 的符号位（正数补 0，负数补 1），最右边那个位直接舍去。用8位二进制数举个例子： $$-5_{(10)} = 1111~1011_{(2)}，-5 >> 1 =1111~1101 _{(2)} = -3$$
所以在这里这一步是$(x|(~x + 1)) >> 31$,
对于无符号整数，必须使用逻辑右移，也就是只会补0，没有补1的情况

这时候 如果 x 是 0 我们得到 0,x 非 0得到的是 -1
，最后加上1就好了 (!0 = 1,别忘了)
~~~cpp
int logicalNeg(int x) 
{
  return ((x|(~x + 1)) >> 31) + 1;
}
~~~

## howManyBits
在 Data Lab 题目，比如：

计算“某个数的最高有效位的位置”；
去掉“前导 0”或“前导符号位 1”；
比较“有符号/无符号”的大小。
这些地方说的“有效位”，就是指：

无符号数：去掉左边所有的 0，剩下的那段；
有符号数：
正数：同上，去掉左边的 0；
负数：去掉左边多出来、只用于符号扩展的那一串 1，只保留真正能区分不同负数的那几位。

用人话说就是一些只是为了补足32位或者8位二进制的那些前导0和前导1是不算进去的

在这里还遇到了一个神秘的远古问题
dlc 这个检查工具非常古老，它强制使用 C89 标准。 在 C89 标准中，所有的变量声明必须写在函数的最最最前面，不能夹杂在代码中间

非负数找有效位数比较简单，找到最高位的1就好了，负数因为前导1的存在不能这么简单粗暴找

所以先把负数取反，这样取反后最高位的1（也就是取反前最高位的0），由于不能使用条件语句，我们统一把负数取反，按照正数的处理方式去完成，所以使用 x ^ (x >> 31) 就能完成这个取反了，(x >> 31) 这个东西刚刚在上一题才用了，所以不再细讲

接下来就是模拟一个类似二分/倍增法的过程，判断最高的前 16 8 4 2 1 位是否存在1，然后累加
~~~cpp
int howManyBits(int x) 
{
  //首先我们要统一处理正数，所以先把负数转化成正数，其实就是取反,这样方便消去符号位
  int tag = x >> 31;
  int bit_0,bit_1,bit_2,bit_4,bit_8,bit_16;
  //tag = 0000...0 = 0 ,当 x 非负, tag = 111...1111 = -1,x 是负数
  x = x ^ tag; // tag = 0,x^tag = x; tag = -1, x^tag = ~x
  
  //然后就是伟大的倍增法
  
  bit_16 = !(!(x >> 16)) << 4; //是否高16位有1
  x = x >> bit_16; //有1，则右移16位，否则不变，接下来以此类推
  bit_8 = !(!(x >> 8)) << 3;
  x = x >> bit_8;
  bit_4 = !(!(x >> 4)) << 2;
  x = x >> bit_4;
  bit_2 = !(!(x >> 2)) << 1;
  x = x >> bit_2;
  bit_1 = !(!(x >> 1));
  x = x >> bit_1;
  bit_0 = x;
  return bit_0 + bit_1 + bit_2 + bit_4 + bit_8 + bit_16 + 1; 
  //最后加1是因为符号位
}
~~~

$$